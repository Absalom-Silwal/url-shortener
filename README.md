# URL Shortener
A backend URL shortener service that generates unique short links, handles redirection, and tracks basic analytics, built with a focus on clean architecture and scalability.

# Problem Statement
Design and implement a scalable, highly available URL shortening service that converts long URLs into short, unique links and efficiently redirects users while handling high read traffic, failures, and abuse.

# Functional Requirements
- System should be able to generate unique short url generation from long url
- System should be able to redirect to long url on short url given

# Non Functional Requirements
- System should be highly available.
- System should be horizontally scalable (adding more servers) at the peak time. 
- System should performed at low latency(less time between request and server response).
- The short urls generated by the system should be highly unpredictable.

# Resource Estimation
Assumptions
- 50 million daily active user
- User send 5 url shortening request per day on average
- Read to write ratio is 100:1 (for each write, there will be 100 read request)
- Url shortening requires 500 bytes of database storage
- 3 years of expiry time.

QPS(Query per Second)
- Average writes per sec = 50 million * 5 / (24 * 60 * 60) = 250 million / 86400 = 2,893 writes/sec
- Average reads per sec = 250 million * 100 / (24 * 60 * 60) ~ ≈ 289,351 reads/sec

Peak QPS
- Assume 5X would be the peak
- Peak Write QPS  = 2,893 × 5 ≈ 14,500 writes/sec
- Peak Read QPS = 289,351 × 5 ≈ 1.45 million reads/sec

Storage
- Total writes for 3 years = 250 M * 365 * 3  = 273.75 billion URLs 
- Total Storage = 273.75 billion URLs * 500 bytes ≈ 136.9 TB

Cache
- Let's assume caching 0.1% hot URLs
- hot URLs = 273.75B × 0.1% = 273M URLs
- Cache Size = 273M * 500 bytes ≈ 109 GB
- Final Redis cache : 120-150 GB



# High-level architecture diagram

<img src="./assets/images/high_level_architecture.png" alt="Example image" width="450" height="200">


# API design
1. POST /shorten Create Short URL

- Request Body<br>
{<br>
  "long_url": "https://www.example.com/long-path",<br>
}

- Response Body <br>
{<br>
  "short_url": "https://api.short.com/{short_code}",<br>
  "short_code": {short_code},<br>
  "expire_at": "2029-01-01T00:00:00Z"<br>
}<br>


2. GET /{short_url} Redirect Short URL

- Response <br>

HTTP/1.1 302 Found<br>
Location: https://www.example.com/long-path <br>
Cache-Control: no-cache <br>


# Trade-offs

- Programming language Choice

Node.js was selected as the backend language for the URL shortener because its event-driven, non-blocking I/O architecture aligns strongly with the system’s functional and non-functional requirements. The application is highly read-heavy and I/O-bound, requiring low-latency redirects and the ability to handle a very large number of concurrent requests efficiently. Node.js enables fast redirect handling, scalable REST API development, and stateless service design that supports horizontal scaling behind a load balancer. From a non-functional perspective, it offers strong scalability, efficient resource utilization, high availability. While Node.js is not ideal for CPU-intensive workloads, this limitation is acceptable for a URL shortener, as heavy processing tasks can be handled asynchronously, making Node.js a well-balanced and scalable choice for this system.

- Database Choice

MongoDB was chosen as the primary database because it aligns well with the URL shortener’s functional and non-functional requirements. The system relies on simple key-based access patterns, high read throughput, and long-lived data with automatic expiry, all of which are well supported by MongoDB’s document model and TTL indexes.<br> Its native sharding and replica set capabilities enable horizontal scalability and high availability without introducing excessive operational complexity. While MongoDB trades strong consistency and complex relational queries for flexibility and ease of scaling, these trade-offs are acceptable for a read-heavy, low-latency URL shortener, making MongoDB a practical and scalable database choice.

- ID Generation Strategy

- Auto Increment ID
It is highly predictable so it's not choosen

- UUID<br>
It is guranteed to be unique. But Due to it's long length, it isnot choosen

- Random Base62 String <br>
This strategy has collision probability at scale. This requires continues checking the database and retries

- Snowflake-Style Distributed IDs <br>
Each service instances generates IDs independently.When Encoded using Base62 produces short .Guranteed Uniqueness and no retries

ID Structure <br>
| Timestamp | Machine ID | Sequence |



- Caching Strategy

A multi-layer caching strategy using a CDN and Redis was chosen to optimize the read-heavy nature of the URL shortener. Redirect responses are cached at the CDN for ultra-low latency global access, while Redis serves as the primary application-level cache for short-to-long URL mappings. A cache-aside approach with TTL-based eviction ensures efficient memory usage and automatic cleanup aligned with URL expiry. Although this design introduces cache consistency and memory management trade-offs, it significantly reduces database load, improves scalability, and ensures fast and reliable redirects under high traffic.


# Failure handling
- Cache Failures
- Database Failures
- Application Server Failures
- Load Balancer Failures

# Future improvements